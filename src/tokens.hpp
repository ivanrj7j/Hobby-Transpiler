#pragma once

#include <string>
using namespace std;

enum TokenType { _keyWord,
    _identifier,
    _literal,
    _operator,
    _delimiter,
    _comment,
    _whitespace,
    _expression };
enum KeyWordType { _if,
    _elif,
    _else,
    _for,
    _while,
    _do,
    _return,
    _break,
    _continue,
    _int,
    _float,
    _string,
    _char,
    _bool };
enum LiteralType { _intLit,
    _floatLit,
    _stringLit,
    _charLit };
enum OperatorType { _add,
    _sub,
    _mul,
    _div,
    _mod,
    _pow,
    _and,
    _or,
    _not,
    _xor,
    _eq,
    _neq,
    _gte,
    _lte,
    _gt,
    _lt,
    _ass,
    _assAdd,
    _assSub,
    _assMul,
    _assDiv,
    _assMod,
    _assPow };
enum DelimiterType { _bracketOpen,
    _bracketClose,
    _braceOpen,
    _braceClose,
    _sqOpen,
    _sqClose };
enum WhiteSpaceType { _space,
    _tab,
    _newLine };

class _Token {
public:
    TokenType tokenType;
    int16_t token;
    string value;

    _Token(TokenType tokenType, int16_t token, string value)
    {
        this->tokenType = tokenType;
        this->token = token;
        this->value = value;
    }
};

class Token {
private:
    TokenType tokenType;
    KeyWordType keywordType;
    LiteralType literalType;
    OperatorType operatorType;
    DelimiterType delimiterType;
    WhiteSpaceType whiteSpaceType;
    string token;

public:
    // Associativity for operators
    enum Associativity { LeftAssoc,
        RightAssoc,
        NonAssoc };

    Token()
    {
        this->tokenType = _expression;
    }

    Token(KeyWordType keywordType)
    {
        this->tokenType = _keyWord;
        this->keywordType = keywordType;
    }

    Token(LiteralType literalType, string value)
    {
        this->literalType = literalType;
        this->tokenType = _literal;
        this->token = value;
    }

    Token(OperatorType operatorType)
    {
        this->tokenType = _operator;
        this->operatorType = operatorType;
    }

    Token(DelimiterType delimiterType)
    {
        this->tokenType = _delimiter;
        this->delimiterType = delimiterType;
    }

    Token(WhiteSpaceType whiteSpaceType)
    {
        this->tokenType = _whitespace;
        this->whiteSpaceType = whiteSpaceType;
    }

    Token(string comment)
    {
        this->token = comment;
        this->tokenType = _comment;
    }

    _Token get()
    {
        int16_t token;
        switch (this->tokenType) {
        case _keyWord:
            token = this->keywordType;
            break;
        case _literal:
            token = this->literalType;
            break;
        case _operator:
            token = this->operatorType;
            break;
        case _delimiter:
            token = this->delimiterType;
            break;
        case _whitespace:
            token = this->whiteSpaceType;
            break;
        case _comment:
            break;
        case _identifier:
            break;
        case _expression:
            break;
        default:
            throw invalid_argument("The type of token given is incorrect");
        }
        return _Token(this->tokenType, token, this->token);
    }

    int getPriority() const
    {
        // this method was generated by ai 
        if (this->tokenType != _operator) {
            return 0;
        }
        switch (this->operatorType) {
        case _pow:
            return 80;
        case _mul:
        case _div:
        case _mod:
            return 60;
        case _add:
        case _sub:
            return 50;
        case _gt:
        case _lt:
        case _gte:
        case _lte:
            return 40;
        case _eq:
        case _neq:
            return 35;
        case _and:
            return 30;
        case _xor:
            return 25;
        case _or:
            return 20;
        case _not:
            return 70;
        case _ass:
        case _assAdd:
        case _assSub:
        case _assMul:
        case _assDiv:
        case _assMod:
        case _assPow:
            return 10;
        default:
            return 0;
        }
    }

    Associativity getAssociativity() const
    {
        // this method was generated by ai 
        if (this->tokenType != _operator) {
            return NonAssoc;
        }
        switch (this->operatorType) {
        // right-associative operators
        case _pow:
        case _not:
        case _ass:
        case _assAdd:
        case _assSub:
        case _assMul:
        case _assDiv:
        case _assMod:
        case _assPow:
            return RightAssoc;
        // most binary operators are left-associative
        case _mul:
        case _div:
        case _mod:
        case _add:
        case _sub:
        case _gt:
        case _lt:
        case _gte:
        case _lte:
        case _eq:
        case _neq:
        case _and:
        case _xor:
        case _or:
            return LeftAssoc;
        default:
            return NonAssoc;
        }
    }

    static Token identifier(string name)
    {
        Token token;
        token.tokenType = _identifier;
        token.token = name;
        return token;
    }
};